package org.firstinspires.ftc.teamcode;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.arcrobotics.ftclib.controller.PIDController;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;

import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.hardware.gobilda.GoBildaPinpointDriver;



@Autonomous(name="tswontwork")
public class OFFtry extends LinearOpMode {
    public PIDController rotation;
    public static double prot = 0.08, irot = 0, drot = 0.00001;
    public static double targetrot = 0;
    public static double f = 0;
    DcMotor frontLeft, frontRight, backLeft, backRight;
    DcMotorEx spin1;
    DcMotorEx spin2;
    //--Intake--
    DcMotor intake;

    IMU imu;
    DcMotor turret;

    double x = 0.0, y = 0.0,theta = 0.0;
    double lastXWheel = 0.0, lastYWheel = 0.0;

    final double TICKS_PER_REV = 8192;
    final double WHEEL_DIAMETER_CM = 3.0;
    final double TICKS_TO_CM = (double) 46 / 9002;

    //final double Kp_xy = 0.14;
    final double Kp_xy = 0.01;
    final double Kp_theta = 0.12;
    public PIDController shooter;
    public static double pshoot = 0.02, ishoot = 0.2, dshoot = 0;
    private double shottarget = -2340;

    final double MIN_TRANSLATION_POWER = 0.1;
    final double MIN_ROTATION_POWER = 0.05;

    final double POSITION_TOLERANCE = 1.0;  // cm
    final double ANGLE_TOLERANCE = Math.toRadians(2);

    class Pose2d {
        double x, y,theta;
        Pose2d(double x, double y, double theta) { this.x = x; this.y = y; this.theta =theta; }
    }

    @Override
    public void runOpMode() {
        rotation = new PIDController(prot, irot , drot);
        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());
        shooter = new PIDController(pshoot,ishoot,dshoot);



        frontLeft  = hardwareMap.get(DcMotor.class, "FL");
        frontRight = hardwareMap.get(DcMotor.class, "FR");
        backLeft   = hardwareMap.get(DcMotor.class, "BL");
        backRight  = hardwareMap.get(DcMotor.class, "BR");
        intake     = hardwareMap.get(DcMotor.class, "intake");
        spin1 = hardwareMap.get(DcMotorEx.class, "shootup");
        spin2 = hardwareMap.get(DcMotorEx.class, "shootdown");

        turret = hardwareMap.get(DcMotor.class, "turret");






        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        GoBildaPinpointDriver pinpoint = hardwareMap.get(GoBildaPinpointDriver.class, "pinpoint");

        pinpoint.setEncoderResolution(GoBildaPinpointDriver.GoBildaOdometryPods.goBILDA_4_BAR_POD);
        pinpoint.setOffsets(0, 0, DistanceUnit.MM);
        pinpoint.setEncoderDirections(GoBildaPinpointDriver.EncoderDirection.REVERSED, GoBildaPinpointDriver.EncoderDirection.REVERSED);
        telemetry.addLine("Initialized. Waiting for start...");
        telemetry.update();

        waitForStart();
        pinpoint.recalibrateIMU();
        sleep(250);

        while (opModeIsActive()) {
            pinpoint.recalibrateIMU();


            sleep(500);
            pinpoint.update();
//            telemetry.addData("X CM", pinpoint.getPosX(DistanceUnit.CM));
//            telemetry.addData("Y CM", pinpoint.getPosY(DistanceUnit.CM));
//            telemetry.addData("H Degrees", pinpoint.getHeading(AngleUnit.DEGREES));
//            telemetry.update();
            moveToTarget(0,20,false);
        }

        //setMecanumPowers(0,0,0);
    }

    Pose2d getRobotPose() {
        GoBildaPinpointDriver pinpoint = hardwareMap.get(GoBildaPinpointDriver.class, "pinpoint");

        pinpoint.setEncoderResolution(GoBildaPinpointDriver.GoBildaOdometryPods.goBILDA_4_BAR_POD);
        pinpoint.setOffsets(0, 0, DistanceUnit.MM);
        pinpoint.setEncoderDirections(GoBildaPinpointDriver.EncoderDirection.REVERSED, GoBildaPinpointDriver.EncoderDirection.REVERSED);

        pinpoint.update();
        double xWheel = pinpoint.getPosX(DistanceUnit.CM);
        double yWheel = pinpoint.getPosY(DistanceUnit.CM);

        double deltaXWheel = xWheel - lastXWheel;
        double deltaYWheel = yWheel - lastYWheel;

        lastXWheel = xWheel;
        lastYWheel = yWheel;
        theta = pinpoint.getHeading(AngleUnit.DEGREES);

        double deltaX = deltaXWheel * Math.cos(theta) - deltaYWheel * Math.sin(theta);
        double deltaY = deltaXWheel * Math.sin(theta) + deltaYWheel * Math.cos(theta);

        x += deltaX;
        y += deltaY;

        return new Pose2d(x, y,theta);
    }

    double normalizeAngle(double angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }

    void rotate(double angle ){
        while(opModeIsActive()) {
            targetrot = angle;
            rotation.setPID(prot, irot, drot);
            double omegarot = 1;

            telemetry.addData("omega :", omegarot);
            telemetry.addData("target: ", targetrot);
            telemetry.update();

            double pidshot = rotation.calculate(omegarot, targetrot);

            double ff = Math.cos(Math.toRadians(targetrot)) * 0;

            double pow = pidshot + ff;
            double powerFL = +pow;
            double powerBL = -pow;
            double powerFR = +pow;
            double powerBR = -pow;
            frontLeft.setPower(powerFL);
            backLeft.setPower(powerBL);
            frontRight.setPower(powerFR);
            backRight.setPower(powerBR);
            double errorofit = targetrot-omegarot;


            if(-0.3 < errorofit && errorofit < 0.3){
                break;

            }

        }

    }

    void justrpm(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();

            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current > last){
                break;

            }
        }





    }
    void shoot(double last, boolean kickuptrue){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        sleep(500);
        while(opModeIsActive()){
            current = sec.seconds();

            intake.setPower(1);



            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current >  last){
                break;

            }
        }



    }


    void moveToTarget(double targetX, double targetY, boolean runintake) {
        while (opModeIsActive()) {

            Pose2d pose = getRobotPose();
            double targetTheta = 0;
            double errorX = targetX - pose.x;
            double errorY = targetY - pose.y;
            double errorTheta = normalizeAngle(targetTheta - pose.theta);

            // Convert to robot-relative frame
//            double errorForward = errorX * Math.cos(pose.theta) + errorY * Math.sin(pose.theta);
//            double errorStrafe  = -errorX * Math.sin(pose.theta) + errorY * Math.cos(pose.theta);

            // Apply proportional control
//            double driveForward = Kp_xy * errorForward;
//            double driveStrafe  = Kp_xy * errorStrafe;
            double driveForward = Kp_xy * errorX;
            double driveStrafe  = Kp_xy * errorY;

            // Ensure minimum translation
            if (Math.abs(driveForward) < MIN_TRANSLATION_POWER && Math.abs(errorX) > 0.5)
                driveForward = Math.signum(driveForward) * MIN_TRANSLATION_POWER;
            if (Math.abs(driveStrafe) < MIN_TRANSLATION_POWER && Math.abs(errorY) > 0.5)
                driveStrafe = Math.signum(driveStrafe) * MIN_TRANSLATION_POWER;

            // Rotation control with deadzone
            double turnPower = Kp_theta * errorTheta;
            if (Math.abs(errorTheta) < Math.toRadians(1)) turnPower = 0;
            else if (Math.abs(turnPower) < MIN_ROTATION_POWER) turnPower = Math.signum(turnPower) * MIN_ROTATION_POWER;

            // Apply powers to mecanum
            setMecanumPowers(driveForward, driveStrafe, turnPower);

            telemetry.addData("Target", "(%.1f, %.1f, %.1f°)", targetX, targetY, Math.toDegrees(targetTheta));
            telemetry.addData("Pose", "(%.1f, %.1f, %.1f°)", pose.x, pose.y, pose.theta);
//            telemetry.addData("Error θ", "%.1f°", Math.toDegrees(errorTheta));
            telemetry.update();

            if (Math.abs(errorX) < POSITION_TOLERANCE &&
                    Math.abs(errorY) < POSITION_TOLERANCE){
                break;
            }

        }

        setMecanumPowers(0,0,0);
    }

    void setMecanumPowers(double strafe, double forward, double rotate) {
        double fl = -forward - strafe + rotate;
        double fr = -forward + strafe - rotate;
        double bl = -forward + strafe + rotate;
        double br = -forward - strafe - rotate;

        double max = Math.max(1.0, Math.max(Math.abs(fl),
                Math.max(Math.abs(fr), Math.max(Math.abs(bl), Math.abs(br)))));
        fl /= max; fr /= max; bl /= max; br /= max;

        frontLeft.setPower(fl);
        frontRight.setPower(fr);
        backLeft.setPower(bl);
        backRight.setPower(br);
//        telemetry.addData("FL:", fl);
//        telemetry.addData("FR:", fr);
//        telemetry.addData("BL:", bl);
//        telemetry.addData("BR:", br);
//        telemetry.update();
    }
    void kickupball(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();

            if(current == last){

                break;

            }
        }





    }

    void rotateToAngle(double targetAngleDegrees) {
        double targetAngle = Math.toRadians(targetAngleDegrees);
        double Kp = 0.1;  // proportional control constant
        double MIN_POWER = 0.05;
        double MAX_POWER = 0.4;
        double TOLERANCE = Math.toRadians(2); // within ±2°

        while (opModeIsActive()) {
//            double currentAngle = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
            double currentAngle = 1;
            double error = normalizeAngle(targetAngle - currentAngle);

            // Break if close enough
            if (Math.abs(error) < TOLERANCE) break;

            // Proportional control
            double power = 0.5;

            // Clamp power
//            power = Math.max(-MAX_POWER, Math.min(MAX_POWER, power));

            // Apply minimum turning power
            if (Math.abs(power) < MIN_POWER)
                power = Math.signum(power) * MIN_POWER;

            // Apply rotation (all wheels turn in opposite directions)
            frontLeft.setPower(power);
            backLeft.setPower(-power);
            frontRight.setPower(power);
            backRight.setPower(-power);

            telemetry.addData("Target Angle", Math.toDegrees(targetAngle));
            telemetry.addData("Current Angle", Math.toDegrees(currentAngle));
            telemetry.addData("Error", Math.toDegrees(error));
            telemetry.addData("Power", power);
            telemetry.addLine("(┬┬﹏┬┬)");
            telemetry.update();
        }

        // Stop all motors
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }
}
