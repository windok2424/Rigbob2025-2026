package org.firstinspires.ftc.teamcode;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.arcrobotics.ftclib.controller.PIDController;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Holonomic")
public class Holonomic_blue extends LinearOpMode {
    public PIDController rotation;
    public static double prot = 0.08, irot = 0, drot = 0.00001;
    public static double targetrot = 0;
    public static double f = 0;
    DcMotor frontLeft, frontRight, backLeft, backRight;
    DcMotorEx spin1;
    DcMotorEx spin2;
    //--Intake--
    DcMotor intake;
    CRServo roll_left;
    CRServo roll_right;

    CRServo up_left;
    CRServo up_right;

    Servo kickup;
    Servo holdfast;
    IMU imu;
    DcMotor turret;

    double x = 0.0, y = 0.0, theta = 0.0;
    double lastXWheel = 0.0, lastYWheel = 0.0;

    final double TICKS_PER_REV = 8192;
    final double WHEEL_DIAMETER_CM = 3.0;
    final double TICKS_TO_CM = 46/9002;

    //final double Kp_xy = 0.14;
    final double Kp_xy = 0.3;
    final double Kp_theta = 0.12;
    public PIDController shooter;
    public static double pshoot = 0.02, ishoot = 0.2, dshoot = 0;
    private double shottarget = -2340;

    final double MIN_TRANSLATION_POWER = 0.1;
    final double MIN_ROTATION_POWER = 0.05;

    final double POSITION_TOLERANCE = 1.0;  // cm
    final double ANGLE_TOLERANCE = Math.toRadians(2);

    class Pose2d {
        double x, y, theta;
        Pose2d(double x, double y, double theta) { this.x = x; this.y = y; this.theta = theta; }
    }

    @Override
    public void runOpMode() {
        rotation = new PIDController(prot, irot , drot);
        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());
        shooter = new PIDController(pshoot,ishoot,dshoot);



        frontLeft  = hardwareMap.get(DcMotor.class, "FL");
        frontRight = hardwareMap.get(DcMotor.class, "FR");
        backLeft   = hardwareMap.get(DcMotor.class, "BL");
        backRight  = hardwareMap.get(DcMotor.class, "BR");
        intake     = hardwareMap.get(DcMotor.class, "intake");
        roll_left = hardwareMap.get(CRServo.class, "inspin1");
        roll_right = hardwareMap.get(CRServo.class, "inspin2");
        spin1 = hardwareMap.get(DcMotorEx.class, "shootup");
        spin2 = hardwareMap.get(DcMotorEx.class, "shootdown");
        turret = hardwareMap.get(DcMotor.class, "turret");

        up_left = hardwareMap.get(CRServo.class, "spinup1");
        up_right = hardwareMap.get(CRServo.class, "spinup2");
        kickup = hardwareMap.get(Servo.class, "kickup");
        holdfast = hardwareMap.get(Servo.class, "hold");

        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        imu = hardwareMap.get(IMU.class, "imu");
        IMU.Parameters imuParams = new IMU.Parameters(
                new RevHubOrientationOnRobot(
                        RevHubOrientationOnRobot.LogoFacingDirection.RIGHT,
                        RevHubOrientationOnRobot.UsbFacingDirection.BACKWARD
                )
        );
        imu.initialize(imuParams);
        imu.resetYaw();

        telemetry.addLine("Initialized. Waiting for start...");
        telemetry.update();

        waitForStart();



        if (opModeIsActive()) {
            holdfast.setPosition(1);

            justrpm(3);
            shoot(5,    false);

            shoot(1, true);

            //movemnet

            moveToTarget(-15, -9 ,true);


            holdfast.setPosition(0);
//            sleep(1000);
            moveToTarget(-14, -28 , true);
            //this is after intake 1
            moveToTarget(0,0,false);
            rotate(0);
            holdfast.setPosition(1);

            sleep(1000);

            //time to shoot

            justrpm(2);
            shoot(4,    false);
            shoot(1, true);



//            moveToTarget(-27.5,-9,true);
//            rotate(0);
//            moveToTarget(-26.5,-28.5,true);
//            moveToTarget(0,0,false);
//            holdfast.setPosition(1);
//            rotate(0);
//            sleep(1000);
//
//            justrpm(2);
//            shoot(2,    false);
//            shoot(1, true);
//            moveToTarget(-15, -9 ,true);
//

//            moveToTarget(20, 20);
//
//            moveToTarget(20, 0);
//
//            moveToTarget(0, 0);
//
        }

        setMecanumPowers(0,0,0);
    }

    Pose2d getRobotPose() {
        double xWheel = backLeft.getCurrentPosition() * TICKS_TO_CM;
        double yWheel = -frontLeft.getCurrentPosition() * TICKS_TO_CM;

        double deltaXWheel = xWheel - lastXWheel;
        double deltaYWheel = yWheel - lastYWheel;

        lastXWheel = xWheel;
        lastYWheel = yWheel;

        theta = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

        double deltaX = deltaXWheel * Math.cos(theta) - deltaYWheel * Math.sin(theta);
        double deltaY = deltaXWheel * Math.sin(theta) + deltaYWheel * Math.cos(theta);

        x += deltaX;
        y += deltaY;

        return new Pose2d(x, y, theta);
    }

    double normalizeAngle(double angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }

    void rotate(double angle ){
        while(opModeIsActive()) {
            targetrot = angle;
            rotation.setPID(prot, irot, drot);
            double omegarot = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES);

            telemetry.addData("omega :", omegarot);
            telemetry.addData("target: ", targetrot);
            telemetry.update();

            double pidshot = rotation.calculate(omegarot, targetrot);

            double ff = Math.cos(Math.toRadians(targetrot)) * 0;

            double pow = pidshot + ff;
//
//        shootup.setPower(powershot);
//        shootdown.setPower(powershot);
            double powerFL = +pow;
            double powerBL = -pow;
            double powerFR = +pow;
            double powerBR = -pow;
            frontLeft.setPower(powerFL);
            backLeft.setPower(powerBL);
            frontRight.setPower(powerFR);
            backRight.setPower(powerBR);
            double errorofit = targetrot-omegarot;


            if(-0.3 < errorofit && errorofit < 0.3){
                break;

            }

        }

    }

    void justrpm(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();

            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current > last){
                break;

            }
        }





    }
    void shoot(double last, boolean kickuptrue){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        holdfast.setPosition(1);
        sleep(500);
        while(opModeIsActive()){
            current = sec.seconds();

            intake.setPower(1);
            roll_left.setPower(1);
            roll_right.setPower(-1);
            up_left.setPower(-1);
            up_right.setPower(1);

            if(kickuptrue){
                kickup.setPosition(0);

            }
            else {

                kickup.setPosition(1);
            }

            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current >  last){
                break;

            }
        }



    }


    void moveToTarget(double targetX, double targetY, boolean runintake) {
        while (opModeIsActive()) {
            kickup.setPosition(1);
            Pose2d pose = getRobotPose();
            double targetTheta = 0;
            double errorX = targetX - pose.x;
            double errorY = targetY - pose.y;
            double errorTheta = normalizeAngle(targetTheta - pose.theta);

            // Convert to robot-relative frame
            double errorForward = errorX * Math.cos(pose.theta) + errorY * Math.sin(pose.theta);
            double errorStrafe  = -errorX * Math.sin(pose.theta) + errorY * Math.cos(pose.theta);

            // Apply proportional control
            double driveForward = Kp_xy * errorForward;
            double driveStrafe  = Kp_xy * errorStrafe;

            // Ensure minimum translation
            if (Math.abs(driveForward) < MIN_TRANSLATION_POWER && Math.abs(errorForward) > 0.5)
                driveForward = Math.signum(driveForward) * MIN_TRANSLATION_POWER;
            if (Math.abs(driveStrafe) < MIN_TRANSLATION_POWER && Math.abs(errorStrafe) > 0.5)
                driveStrafe = Math.signum(driveStrafe) * MIN_TRANSLATION_POWER;

            // Rotation control with deadzone
            double turnPower = Kp_theta * errorTheta;
            if (Math.abs(errorTheta) < Math.toRadians(1)) turnPower = 0;
            else if (Math.abs(turnPower) < MIN_ROTATION_POWER) turnPower = Math.signum(turnPower) * MIN_ROTATION_POWER;

            // Apply powers to mecanum
            setMecanumPowers(driveStrafe, driveForward, turnPower);

            telemetry.addData("Target", "(%.1f, %.1f, %.1f°)", targetX, targetY, Math.toDegrees(targetTheta));
            telemetry.addData("Pose", "(%.1f, %.1f, %.1f°)", pose.x, pose.y, Math.toDegrees(pose.theta));
//            telemetry.addData("Error θ", "%.1f°", Math.toDegrees(errorTheta));
            telemetry.update();

            if (Math.abs(errorX) < POSITION_TOLERANCE &&
                    Math.abs(errorY) < POSITION_TOLERANCE){
                break;
            }
            if(runintake){


                intake.setPower(1);
                roll_left.setPower(1);
                roll_right.setPower(-1);
                up_left.setPower(-1);
                up_right.setPower(1);
                holdfast.setPosition(0);

            }
            else{
                sleep(100);
                intake.setPower(1);
                roll_left.setPower(0);
                roll_right.setPower(-0);
                up_left.setPower(-0);
                up_right.setPower(0);
                holdfast.setPosition(1);


            }
        }

        setMecanumPowers(0,0,0);
    }

    void setMecanumPowers(double strafe, double forward, double rotate) {
        double fl = forward + strafe + rotate;
        double fr = forward - strafe - rotate;
        double bl = forward - strafe + rotate;
        double br = forward + strafe - rotate;

        double max = Math.max(1.0, Math.max(Math.abs(fl),
                Math.max(Math.abs(fr), Math.max(Math.abs(bl), Math.abs(br)))));
        fl /= max; fr /= max; bl /= max; br /= max;

        frontLeft.setPower(fl);
        frontRight.setPower(fr);
        backLeft.setPower(bl);
        backRight.setPower(br);
    }
    void kickupball(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();
            roll_left.setPower(1);
            roll_right.setPower(-1);
            up_left.setPower(-1);
            up_right.setPower(1);
            kickup.setPosition(1);
            if(current == last){
                kickup.setPosition(0);
                break;

            }
        }





    }

    void rotateToAngle(double targetAngleDegrees) {
        double targetAngle = Math.toRadians(targetAngleDegrees);
        double Kp = 0.1;  // proportional control constant
        double MIN_POWER = 0.05;
        double MAX_POWER = 0.4;
        double TOLERANCE = Math.toRadians(2); // within ±2°

        while (opModeIsActive()) {
            double currentAngle = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
            double error = normalizeAngle(targetAngle - currentAngle);

            // Break if close enough
            if (Math.abs(error) < TOLERANCE) break;

            // Proportional control
            double power = 0.5;

            // Clamp power
//            power = Math.max(-MAX_POWER, Math.min(MAX_POWER, power));

            // Apply minimum turning power
            if (Math.abs(power) < MIN_POWER)
                power = Math.signum(power) * MIN_POWER;

            // Apply rotation (all wheels turn in opposite directions)
            frontLeft.setPower(power);
            backLeft.setPower(-power);
            frontRight.setPower(power);
            backRight.setPower(-power);

            telemetry.addData("Target Angle", Math.toDegrees(targetAngle));
            telemetry.addData("Current Angle", Math.toDegrees(currentAngle));
            telemetry.addData("Error", Math.toDegrees(error));
            telemetry.addData("Power", power);
            telemetry.addLine("(┬┬﹏┬┬)");
            telemetry.update();
        }

        // Stop all motors
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }
}
