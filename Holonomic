package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;

@Autonomous(name="Holonomic_MoveAndRotate")
public class Holonomic_Beta extends LinearOpMode {

    DcMotor frontLeft, frontRight, backLeft, backRight;
    IMU imu;

    double x = 0.0, y = 0.0, theta = 0.0;
    double lastXWheel = 0.0, lastYWheel = 0.0;

    final double TICKS_PER_REV = 8192;
    final double WHEEL_DIAMETER_CM = 3.0;
    final double TICKS_TO_CM = (Math.PI * WHEEL_DIAMETER_CM) / TICKS_PER_REV;

    final double Kp_xy = 0.07;
    final double Kp_theta = 0.12;

    final double MIN_TRANSLATION_POWER = 0.1;
    final double MIN_ROTATION_POWER = 0.05;

    final double POSITION_TOLERANCE = 1.0;  // cm
    final double ANGLE_TOLERANCE = Math.toRadians(2);

    class Pose2d {
        double x, y, theta;
        Pose2d(double x, double y, double theta) { this.x = x; this.y = y; this.theta = theta; }
    }

    @Override
    public void runOpMode() {
        frontLeft  = hardwareMap.get(DcMotor.class, "FL");
        frontRight = hardwareMap.get(DcMotor.class, "FR");
        backLeft   = hardwareMap.get(DcMotor.class, "BL");
        backRight  = hardwareMap.get(DcMotor.class, "BR");

        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        backRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        imu = hardwareMap.get(IMU.class, "imu");
        IMU.Parameters imuParams = new IMU.Parameters(
                new RevHubOrientationOnRobot(
                        RevHubOrientationOnRobot.LogoFacingDirection.RIGHT,
                        RevHubOrientationOnRobot.UsbFacingDirection.BACKWARD
                )
        );
        imu.initialize(imuParams);
        imu.resetYaw();

        telemetry.addLine("Initialized. Waiting for start...");
        telemetry.update();

        waitForStart();

        if (opModeIsActive()) {
            //moveToTarget(0, 20);
            rotateToAngle(90);
//            moveToTarget(20, 20);
//            rotateToAngle(0);
//            moveToTarget(20, 0);
//            rotateToAngle(0);
//            moveToTarget(0, 0);
//            rotateToAngle(0);
        }

        setMecanumPowers(0,0,0);
    }

    Pose2d getRobotPose() {
        double xWheel = backLeft.getCurrentPosition() * TICKS_TO_CM;
        double yWheel = -backRight.getCurrentPosition() * TICKS_TO_CM;

        double deltaXWheel = xWheel - lastXWheel;
        double deltaYWheel = yWheel - lastYWheel;

        lastXWheel = xWheel;
        lastYWheel = yWheel;

        theta = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

        double deltaX = deltaXWheel * Math.cos(theta) - deltaYWheel * Math.sin(theta);
        double deltaY = deltaXWheel * Math.sin(theta) + deltaYWheel * Math.cos(theta);

        x += deltaX;
        y += deltaY;

        return new Pose2d(x, y, theta);
    }

    double normalizeAngle(double angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }

    void moveToTarget(double targetX, double targetY) {
        while (opModeIsActive()) {
            Pose2d pose = getRobotPose();
            double targetTheta = 0;
            double errorX = targetX - pose.x;
            double errorY = targetY - pose.y;
            double errorTheta = normalizeAngle(targetTheta - pose.theta);

            // Convert to robot-relative frame
            double errorForward = errorX * Math.cos(pose.theta) + errorY * Math.sin(pose.theta);
            double errorStrafe  = -errorX * Math.sin(pose.theta) + errorY * Math.cos(pose.theta);

            // Apply proportional control
            double driveForward = Kp_xy * errorForward;
            double driveStrafe  = Kp_xy * errorStrafe;

            // Ensure minimum translation
            if (Math.abs(driveForward) < MIN_TRANSLATION_POWER && Math.abs(errorForward) > 0.5)
                driveForward = Math.signum(driveForward) * MIN_TRANSLATION_POWER;
            if (Math.abs(driveStrafe) < MIN_TRANSLATION_POWER && Math.abs(errorStrafe) > 0.5)
                driveStrafe = Math.signum(driveStrafe) * MIN_TRANSLATION_POWER;

            // Rotation control with deadzone
            double turnPower = Kp_theta * errorTheta;
            if (Math.abs(errorTheta) < Math.toRadians(1)) turnPower = 0;
            else if (Math.abs(turnPower) < MIN_ROTATION_POWER) turnPower = Math.signum(turnPower) * MIN_ROTATION_POWER;

            // Apply powers to mecanum
            setMecanumPowers(driveStrafe, driveForward, turnPower);

            telemetry.addData("Target", "(%.1f, %.1f, %.1f°)", targetX, targetY, Math.toDegrees(targetTheta));
            telemetry.addData("Pose", "(%.1f, %.1f, %.1f°)", pose.x, pose.y, Math.toDegrees(pose.theta));
//            telemetry.addData("Error θ", "%.1f°", Math.toDegrees(errorTheta));
            telemetry.update();

            if (Math.abs(errorX) < POSITION_TOLERANCE &&
                    Math.abs(errorY) < POSITION_TOLERANCE){
//                    Math.abs(errorTheta) < ANGLE_TOLERANCE){
                break;
            }
        }

        setMecanumPowers(0,0,0);
    }

    void setMecanumPowers(double strafe, double forward, double rotate) {
        double fl = forward + strafe + rotate;
        double fr = forward - strafe - rotate;
        double bl = forward - strafe + rotate;
        double br = forward + strafe - rotate;

        double max = Math.max(1.0, Math.max(Math.abs(fl),
                Math.max(Math.abs(fr), Math.max(Math.abs(bl), Math.abs(br)))));
        fl /= max; fr /= max; bl /= max; br /= max;

        frontLeft.setPower(fl);
        frontRight.setPower(fr);
        backLeft.setPower(bl);
        backRight.setPower(br);
    }

    void rotateToAngle(double targetAngleDegrees) {
        double targetAngle = Math.toRadians(targetAngleDegrees);
        double Kp = 0.1;  // proportional control constant
        double MIN_POWER = 0.05;
        double MAX_POWER = 0.4;
        double TOLERANCE = Math.toRadians(2); // within ±2°

        while (opModeIsActive()) {
            double currentAngle = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
            double error = normalizeAngle(targetAngle - currentAngle);

            // Break if close enough
            if (Math.abs(error) < TOLERANCE) break;

            // Proportional control
            double power = 0.5;

            // Clamp power
//            power = Math.max(-MAX_POWER, Math.min(MAX_POWER, power));

            // Apply minimum turning power
            if (Math.abs(power) < MIN_POWER)
                power = Math.signum(power) * MIN_POWER;

            // Apply rotation (all wheels turn in opposite directions)
            frontLeft.setPower(power);
            backLeft.setPower(-power);
            frontRight.setPower(power);
            backRight.setPower(-power);

            telemetry.addData("Target Angle", Math.toDegrees(targetAngle));
            telemetry.addData("Current Angle", Math.toDegrees(currentAngle));
            telemetry.addData("Error", Math.toDegrees(error));
            telemetry.addData("Power", power);
            telemetry.addLine("(┬┬﹏┬┬)");
            telemetry.update();
        }

        // Stop all motors
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }
}
