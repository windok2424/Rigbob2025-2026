package org.firstinspires.ftc.teamcode;
import com.arcrobotics.ftclib.controller.PIDController;
import com.qualcomm.hardware.limelightvision.LLFieldMap;

import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotor;

import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;

import com.qualcomm.hardware.limelightvision.LLResult;
import com.qualcomm.hardware.limelightvision.LLResultTypes;
import com.qualcomm.hardware.limelightvision.LLResultTypes.*;
import com.qualcomm.hardware.limelightvision.LLStatus;
import com.qualcomm.hardware.limelightvision.Limelight3A;

import java.util.List;
import com.acmerobotics.*;
import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.config.Config;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.arcrobotics.ftclib.controller.PIDController;
import com.qualcomm.robotcore.*;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;

import com.qualcomm.hardware.gobilda.GoBildaPinpointDriver;
@Autonomous(name = "Scratch")
public class asone extends LinearOpMode {

    // Motors
    DcMotor frontLeft, frontRight, backLeft, backRight;
    DcMotorEx spin1;
    DcMotorEx spin2;
    //--Intake--
    DcMotor intake;
    DcMotor turret;

    // Pinpoint
    GoBildaPinpointDriver pinpoint;

    // Control constants
    public PIDController xpos;
    public PIDController ypos;
    public PIDController thetapos;
    public static double px = -0.05, ix = 0.1, dx = 0.001;
    public static double targetx = 0;
    public static double py = -0.05, iy = 0.1, dy = 0.001;
    public static double targety = 0;
    public static double ptheta = 0.05, itheta = 0, dtheta = 0;
    public static double targettheta = 0;
    public PIDController shooter;
    public static double pshoot = 0.02, ishoot = 0.2, dshoot = 0;
    private double shottarget = -2340;
    final double MIN_TRANSLATION_POWER = 0.12;
    final double MIN_ROTATION_POWER = 0.06;

    final double POSITION_TOLERANCE_CM = 2.0;
    final double ANGLE_TOLERANCE_RAD = Math.toRadians(2);

    @Override
    public void runOpMode() {
        telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());
        shooter = new PIDController(pshoot,ishoot,dshoot);
        xpos = new PIDController(px, ix , dx);
        ypos = new PIDController(py, iy , dy);
        thetapos = new PIDController(ptheta, itheta , dtheta);

        // Motor mapping
        frontLeft  = hardwareMap.get(DcMotor.class, "FL");
        frontRight = hardwareMap.get(DcMotor.class, "FR");
        backLeft   = hardwareMap.get(DcMotor.class, "BL");
        backRight  = hardwareMap.get(DcMotor.class, "BR");
        intake     = hardwareMap.get(DcMotor.class, "intake");
        spin1 = hardwareMap.get(DcMotorEx.class, "shootup");
        spin2 = hardwareMap.get(DcMotorEx.class, "shootdown");

        turret = hardwareMap.get(DcMotor.class, "turret");

        // Motor directions (mecanum)
        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        // Pinpoint setup
        pinpoint = hardwareMap.get(GoBildaPinpointDriver.class, "pinpoint");

        pinpoint.setEncoderResolution(
                GoBildaPinpointDriver.GoBildaOdometryPods.goBILDA_4_BAR_POD
        );

        pinpoint.setOffsets(0, 0, DistanceUnit.MM);

        pinpoint.setEncoderDirections(
                GoBildaPinpointDriver.EncoderDirection.REVERSED,
                GoBildaPinpointDriver.EncoderDirection.REVERSED
        );

        telemetry.addLine("Ready. Waiting for start.");
        telemetry.update();

        waitForStart();

        // Calibrate IMU ONCE
        pinpoint.resetPosAndIMU();
        sleep(500);



        while (opModeIsActive()) {
            // Drive to (0, 20 cm) facing 0°
            move(0, 20, 0);
            sleep(250);
            move(-20, 20, 0);
            sleep(250);
            move(-20,0,0);
            sleep(250);
            move(0,0,0);
            // Stop completely
            setMecanumPowers(0, 0, 0);
            sleep(50);
        }
    }
    void move(double x, double y, double angle) {
        while (opModeIsActive()) {
            pinpoint.update();
            targetx = x;
            targety = y;
            targettheta = angle;
            xpos.setPID(px, ix, dx);
            ypos.setPID(py, iy, dx);
            thetapos.setPID(ptheta, itheta, dtheta);
            double currentx = pinpoint.getPosX(DistanceUnit.CM);
            double currenty = -pinpoint.getPosY(DistanceUnit.CM);
            double currenttheta = pinpoint.getHeading(AngleUnit.DEGREES);
            double errorX = targetx - currentx;
            double errorY = targety - currenty;
            double errortheta = targettheta - currenttheta;


            telemetry.addData("x :", currentx);
            telemetry.addData("target x: ", targetx);
            telemetry.addData("y :", currenty);
            telemetry.addData("target y: ", targety);
            telemetry.addData("theta :", currenttheta);
            telemetry.addData("target theta: ", targettheta);
            telemetry.update();

            double pidx = xpos.calculate(currentx, targetx);
            double pidy = ypos.calculate(currenty, targety);
            double pidtheta = thetapos.calculate(currenttheta, targettheta);
            setMecanumPowers(pidx, pidy, pidtheta);

            telemetry.addData("Target", "(%.1f, %.1f)", targetx, targety);
            telemetry.addData("Pose", "(%.1f, %.1f, %.1f°)",
                    currentx, currenty, currenttheta);
            telemetry.update();

            if (Math.abs(errorX) < POSITION_TOLERANCE_CM &&
                    Math.abs(errorY) < POSITION_TOLERANCE_CM &&
                    Math.abs(errortheta) < ANGLE_TOLERANCE_RAD) {
                break;
            }
        }

    }
    void setMecanumPowers(double strafe, double forward, double rotate) {

        double fl = forward + strafe + rotate;
        double fr = -forward +strafe - rotate;
        double bl = -forward + strafe + rotate;
        double br = forward + strafe - rotate;

        double max = Math.max(1.0,
                Math.max(Math.abs(fl),
                        Math.max(Math.abs(fr),
                                Math.max(Math.abs(bl), Math.abs(br)))));

        frontLeft.setPower(fl / max);
        frontRight.setPower(fr / max);
        backLeft.setPower(bl / max);
        backRight.setPower(br / max);
    }

    double normalizeAngle(double angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }
    void kickupball(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();

            if(current == last){

                break;

            }
        }





    }
    void justrpm(double last){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        while(opModeIsActive()){
            current = sec.seconds();

            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current > last){
                break;

            }
        }





    }
    void shoot(double last, boolean kickuptrue){
        ElapsedTime sec = new ElapsedTime();



        sec.reset();
        double current = sec.seconds();
        sleep(500);
        while(opModeIsActive()){
            current = sec.seconds();

            intake.setPower(1);



            //shooter pid

            shooter.setPID(pshoot, ishoot, dshoot);



            double omega = spin1.getVelocity();
            telemetry.addData("this is the omega", omega);


            double pidshot = shooter.calculate(omega, shottarget);
            omega = omega;

            double ff = Math.cos(Math.toRadians(shottarget)) * 0;

            double powershot = pidshot + ff;

            telemetry.addData("thisis pidshot", pidshot);


            telemetry.update();

            spin1.setPower(powershot);
            spin2.setPower(powershot);

            if(current >  last){
                break;

            }
        }



    }
}
